### 第一讲：基础架构：一条SQL查询语句是如何执行的？
> 一条SQL的执行流程，MySQL的整体架构

### 第二讲：日志系统：一条SQL更新语句是如何执行的？
> redo log 和 binlog
  
### 第三讲：事务隔离：为什么你改了我还看不见？
> 事务隔离级别，事务的生命周期，undo log

### 第四讲：深入浅出索引（上）
> B+树，索引的数据结构

### 第五讲：深入浅出索引（下）
> 各种类型的索引：覆盖索引、前缀索引、索引下推等等

### 第六讲：全局锁和表锁 ：给表加个字段怎么有这么多阻碍？
> 全局锁和表级锁

### 第七讲：行锁功过：怎么减少行锁对性能的影响？
> 行锁

### 第八讲：事务到底是隔离的还是不隔离的？
> 深入隔离级别，一致性读、当前读、行锁的关系

### 第九讲：普通索引和唯一索引，应该怎么选择？
> 从普通索引和唯一索引，redo log，change buffer，唯一索引的坑点

### 第十讲：MySQL为什么有时候会选错索引？
> 优化器怎么选择索引的以及为什么选错索引

### 第十一讲：怎么给字符串字段加索引？
> 索引的实际应用

### 第十二讲：为什么我的MySQL会“抖”一下？
> WAL，redo log，checkpoint

### 第十三讲：为什么表数据删掉一半，表文件大小不变？
> 数据库表的空间回收方法，如何收缩表空间

### 第十四讲：count(*)这么慢，我该怎么办？
> 获得表行数的方法和差别

### 第十五讲：答疑文章（一）：日志和索引相关问题
> redo log buffer，redo log file，redo log，binlog，索引

### 第十六讲：“order by”是怎么工作的？
> order by

### 第十七讲：如何正确地显示随机消息？
> 排序和临时表

### 第十八讲：为什么这些SQL语句逻辑相同，性能却差异巨大？
> 索引失效的情况

### 第十九讲：为什么我只查一行的语句，也执行这么慢？
> 表锁、行锁和一致性读

### 第二十讲：幻读是什么幻读有什么问题？
> 幻读

### 第二十一讲：为什么我只改一行的语句锁这么多？
> 间隙锁

### 第二十二讲：MySQL有哪些“饮鸩止渴”提高性能的方法？
> 慢查询的应急处理

### 第二十三讲：MySQL是怎么保证数据不丢的？
> crash-safe，redo log，binlog

### 第二十四讲：MySQL是怎么保证主备一致的？
>  binlog

### 第二十五讲：MySQL是怎么保证高可用的？
> 高可用，主备策略

### 第二十六讲：备库为什么会延迟好几个小时？
> 主备复制

### 第二十七讲：主库出问题了从库怎么办？
> 主备切换

### 第二十八讲：读写分离有哪些坑？
> 一主多从，读写分离

### 第二十九讲：如何判断一个数据库是不是出问题了？
> MySQL实例健康状态

### 第三十讲：答疑文章（二）：用动态的观点看加锁
> 加锁的规则，范围

### 第三十一讲：误删数据后除了跑路还能怎么办？
> 数据恢复的方法

### 第三十二讲：为什么还有kill不掉的语句？
> kill不掉的语句

### 第三十三讲：我查这么多数据会不会把数据库内存打爆？
> 大查询的影响

### 第三十四讲：到底可不可以使用join？
> join

### 第三十五讲：join语句怎么优化？
> join

### 第三十六讲：为什么临时表可以重名？
> 临时表

### 第三十七讲：什么时候会使用内部临时表？
> group by，union

### 第三十八讲：都说InnoDB好那还要不要使用Memory引擎？
> memory引擎

### 第三十九讲：自增主键为什么不是连续的？
> 自增主键

### 第四十讲：insert语句的锁为什么这么多？
> insert，唯一约束，锁

### 第四十一讲：怎么最快地复制一张表？
> 最快地复制一张表

### 第四十二讲：grant之后要跟着flush privileges吗？
> 用户权限在数据表和内存中的存在形式，以及grant和revoke命令的执行逻辑

### 第四十三讲：要不要使用分区表？
> 分区表

### 第四十四讲：答疑文章（三）：说一说这些好问题
> join，distinct 和 group by，备库自增主键

### 第四十五讲：自增id用完怎么办？
> 自增id达到上限以后的行为


