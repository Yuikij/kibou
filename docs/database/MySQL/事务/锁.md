## 锁的分类

### 锁的粒度
* 全局锁
  * 场景：做全库逻辑备份
* 表级锁
  * 表锁
  * 元数据锁
    * 在访问某张表（增删改查），的时候会加上元数据读锁
    * 注意事项：
      * 当要修改结构的表是热点表的时候，如果此时查询频率很高，会导致服务阻塞
        * 如何避免：在alter table语句里面设定等待时间
      * 待验证：如何长事务select一直占着读锁mdl读锁，这时候进行ddl会阻塞，那么下一个select会阻塞吗
* 行级锁
  * 需要提交事务的时候才会释放所有持有的行锁
  * 注意事项：
    * 要把耗时长的，有可能造成锁冲突的放在事务的后面（共享度最高的那个操作）
    * 避免死锁
      * 设置等待锁的超时时间
      * 启动死锁检查
      * 控制并发度
### 锁的排他性
> 读锁和读锁互不阻塞，有读锁的情况下不能加写锁，有写锁的情况下不能加读锁。已经持有读锁的情况下可以升级成写锁。
* 写锁（Write Lock，也叫作排他锁，eXclusive Lock，简写为 X-Lock）：
* 读锁（Read Lock，也叫作共享锁，Shared Lock，简写为 S-Lock）：

### 锁的具体类型
* 间隙锁
  * 为了解决幻读的问题
  * 间隙锁之间不会冲突，间隙锁与在间隙内插入新记录的插入意向锁互斥
  * 触发条件：
    * 范围查询
    * 非唯一索引的条件等值查询
    * 唯一索引的范围查询
    * 唯一索引等值查询一条不存在的数据
  * 加锁规则
    * 对查询字段进行扫描
    * 间隙锁会锁定查询条件扫描到的索引记录之间的所有间隙
  * 加锁示例（TODO）
  
* 临键锁
* 范围锁
* 意向锁