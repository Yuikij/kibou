### 61.SpringBoot 是如何实现自动配置的？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">Spring Boot</span> <span class="badge badge--secondary">后端</span></summary>

- 入口：`@SpringBootApplication` → `@EnableAutoConfiguration` 导入自动配置。
- 发现机制：读取自动配置清单（Spring Boot 3+ 使用 `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`；旧版使用 `META-INF/spring.factories`）。
- 条件装配：`@ConditionalOnClass/@ConditionalOnMissingBean/@ConditionalOnProperty` 等按需启用配置类，避免重复与冲突。
- 外部化配置：`application.yml/properties` + `@ConfigurationProperties` 实现属性绑定与多环境 `@Profile`。
- 组件化：Starter 仅聚合依赖，AutoConfiguration 提供具体装配逻辑，解耦“依赖选择”与“装配策略”。

</details>

### 62.什么是 MySQL 的主从同步机制？它是如何实现的？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">MySQL</span> <span class="badge badge--secondary">数据库</span></summary>

- 核心流程：主库写入 binlog；从库 I/O 线程通过 TCP 拉取到 relay log；SQL 线程重放 relay log 到从库。
- 复制模式：异步（默认）、半同步（插件，主库等待至少一个从库确认）、组复制/InnoDB Cluster（强一致拓扑）。
- 日志格式：ROW（行级，推荐）、STATEMENT、MIXED。
- 关键问题：主从延迟（大事务、IO 瓶颈、单线程回放）。缓解：并行复制、优化事务、硬件与参数调优、尽量 ROW 格式、拆批。

</details>

### 63.说说 Redisson 分布式锁的原理?
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">后端</span> <span class="badge badge--secondary">Redis</span> <span class="badge badge--secondary">Redisson</span></summary>

- 基于 Redis 的键值锁：`SET lock value NX PX ttl` 或 Lua 保证原子性；`value` 含实例标识与线程标识。
- 可重入：使用 Hash 结构记录同线程重入计数；加锁同线程计数递增。
- 看门狗：持锁任务未主动解锁时，后台定期续期，避免在长业务中锁过期被他人误抢。
- 解锁：校验标识只允许持有者释放；未命中则忽略，避免误删。
- 等待与唤醒：利用 Pub/Sub 通知等待线程重试，减少无效自旋。
- 高可用：多节点用 RedLock 思路（多主多数派），但工程上更推荐哨兵/集群配合主从容灾。

</details>

### 64.如何理解 Spring Boot 中的 starter？
<details>
<summary>展开 <span class="badge badge--info">简单</span> <span class="badge badge--secondary">Spring Boot</span></summary>

- Starter：一组功能边界清晰的依赖聚合（不含装配逻辑），降低坐标选择与版本管理成本。
- AutoConfiguration：承载条件化装配逻辑，随 Starter 引入后按条件生效。
- 命名约定：官方 `spring-boot-starter-*`；第三方 `*-spring-boot-starter`。
- 自定义：拆分 `*-starter`（依赖聚合）与 `*-autoconfigure`（自动配置），并在 `AutoConfiguration.imports` 注册配置类。

</details>

### 65.如何使用 Redis 快速实现排行榜？
<details>
<summary>展开 <span class="badge badge--info">简单</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">后端</span> <span class="badge badge--secondary">Redis</span></summary>

- 使用 ZSet：`ZADD board score member` 写入；`ZREVRANGE board 0 N WITHSCORES` 获取 Top N；`ZINCRBY` 增量变更分数。
- 排名与分数：`ZREVRANK` 获取名次（从 0 开始）；`ZSCORE` 查分数；分页用 `ZREVRANGE start end`。
- 过期与分区：按周期（天/周/月）滚动排行榜；超大榜单可分片或保留 TopK + 近段位数据。
- 去重与并发：member 唯一；批量更新用 Pipeline；必要时加 Lua 保证原子性。

</details>

### 66.Redis 中如何保证缓存与数据库的数据一致性？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">后端</span> <span class="badge badge--secondary">Redis</span></summary>

- 常见策略：Cache-Aside（旁路缓存，最常用）、Read/Write-Through、Write-Behind。
- 写入顺序：先更新 DB 再删除缓存；删除失败用“延迟双删”或订阅 binlog 的异步失效（Canal → MQ → 失效）。
- 过期与回源：设置合理 TTL，热点 Key 提前刷新；穿透用布隆过滤器/空值缓存，击穿用互斥锁，雪崩做 Key 过期随机。
- 幂等与顺序：写入请求加唯一标识；MQ 消费保持幂等；跨库更新需事务或补偿（TCC/Saga）。

</details>

### 67.说说 TCP 的三次握手？
<details>
<summary>展开 <span class="badge badge--info">简单</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">网络</span></summary>

- 步骤：
  1) 客户端 → 服务器：`SYN`（含初始序列号 `ISN_c`）
  2) 服务器 → 客户端：`SYN+ACK`（含 `ISN_s`，确认 `ISN_c+1`）
  3) 客户端 → 服务器：`ACK`（确认 `ISN_s+1`）
- 目的：同步双方序列号与窗口，确认对端收发能力，防止旧连接请求误建立（两次握手无法区分旧 SYN）。
- 相关：防 SYN Flood（半连接队列、SYN Cookies、限速/黑白名单）。

</details>

### 68.简单说说 Netty 的零拷贝机制？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">Netty</span> <span class="badge badge--secondary">后端</span></summary>

- ByteBuf 池化与切片：`slice()/duplicate()` 共享内存不复制，`CompositeByteBuf` 拼接视图减少拼包拷贝。
- 直接内存：`DirectByteBuf` 降低一次用户态/内核态拷贝。
- 文件传输：`FileRegion` 基于 `sendfile` 实现内核级搬运，避免用户态拷贝。
- Linux 原语：`epoll` + `splice`/`mmap` 等在特定场景进一步减少拷贝与上下文切换。

</details>

### 69.什么是配置中心？有哪些常见的配置中心？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">后端</span> <span class="badge badge--secondary">Spring Cloud</span></summary>

- 定义：集中管理应用配置，支持动态下发、灰度、版本、审计与权限控制。
- 常见实现：Nacos、Apollo、Spring Cloud Config、Consul、Etcd、ZooKeeper。
- 客户端：长轮询/推送（HTTP/GRPC）、本地缓存、变更回调（`@RefreshScope`）。

</details>

### 70.说说 TCP 的四次挥手？
<details>
<summary>展开 <span class="badge badge--info">简单</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">网络</span></summary>

- 流程：主动方 `FIN` → 被动方 `ACK`（半关闭）；被动方处理完数据后发送 `FIN`；主动方 `ACK` 并进入 `TIME_WAIT` 等待 2×MSL。
- 目的：确保残留分段过期、处理 ACK 丢失的重传，避免新旧连接串扰。

</details>

### 71.Netty 是如何解决粘包和拆包问题的？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">Netty</span> <span class="badge badge--secondary">后端</span></summary>

- 本质：TCP 是字节流无消息边界，需在应用层定义消息帧。
- 解码器：`LengthFieldBasedFrameDecoder`（常用）、`LineBasedFrameDecoder`、`DelimiterBasedFrameDecoder`、`FixedLengthFrameDecoder`。
- 协议设计：包含长度字段、分隔符、定长帧或 TLV；必要时加 CRC/魔数。

</details>

### 72.Spring Boot 是如何通过 main 方法启动 web 项目的？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">Spring Boot</span> <span class="badge badge--secondary">后端</span></summary>

- `SpringApplication.run()` 启动容器，触发自动配置。
- WebMVC：创建并启动嵌入式 Tomcat/Jetty/Undertow，注册 `DispatcherServlet`、过滤器、拦截器。
- WebFlux：启动 Reactor Netty，注册路由/Handler，基于事件驱动模型。

</details>

### 73.什么情况下需要使用分布式事务，有哪些方案？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">Spring Cloud</span> <span class="badge badge--secondary">微服务</span> <span class="badge badge--secondary">分布式事务</span> <span class="badge badge--secondary">后端</span></summary>

- 适用：跨服务/跨库/跨资源（DB+MQ+缓存）需要一致性保障的场景。
- 方案：
  - XA/2PC：强一致，吞吐低，协调器单点风险。
  - TCC：Try/Confirm/Cancel，业务侵入高但可控性强。
  - Saga：长事务拆分为有补偿的本地事务，最终一致。
  - 本地消息表/Outbox + MQ：事务内落库，异步投递，消费幂等。
  - 工具/框架：Seata（AT/TCC/Saga）、RocketMQ 事务消息等。

</details>

### 74.Redis 为什么这么快？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">后端</span> <span class="badge badge--secondary">Redis</span></summary>

- 内存存储 + 高效编码；单线程避免锁竞争与上下文切换。
- 事件驱动 + 多路复用（epoll/kqueue）减少系统调用成本。
- 高效数据结构（ziplist/listpack、hashtable、skiplist）与命令 O(1)/O(logN)。
- Pipeline、Lua、持久化可调策略（AOF/RDB）与网络优化。

</details>

### 75.如何使用 Redis 快速实现布隆过滤器？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">后端</span> <span class="badge badge--secondary">Redis</span></summary>

- RedisBloom 模块：`BF.RESERVE key errorRate capacity` 创建；`BF.ADD/BF.MADD` 插入；`BF.EXISTS` 判断。
- 原生实现：Bitmap + 多个独立哈希函数；位图规模与误判率成反比。
- 特性：存在误判（假阳性），无漏判（假阴性为 0）；适合快速判重与缓存穿透防护。

</details>

### 76.为什么 Java 中 HashMap 的默认负载因子是 0.75？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--secondary">Java 集合</span> <span class="badge badge--secondary">Java</span></summary>

- 折中选择：在空间利用率与冲突概率之间取平衡；负载因子越大，冲突越多、链/树越长；越小则内存浪费。
- 实践经验：0.75 在通用场景下具备较好查找/插入性能与内存开销的折中。

</details>

### 77.如何处理 MySQL 的主从同步延迟？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">后端</span> <span class="badge badge--secondary">MySQL</span> <span class="badge badge--secondary">数据库</span></summary>

- 读取路由：强一致读走主库；异步业务可读从库。
- 优化复制：启用并行复制、ROW 格式、减少大事务/长事务；合理设置 `sync_binlog`、`innodb_flush_log_at_trx_commit`。
- 架构策略：热点表拆分、异步任务化、削峰填谷；监控延迟并回退读路由。

</details>

### 78.Netty 如何解决 JDK NIO 中的空轮询 Bug？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">Netty</span> <span class="badge badge--secondary">后端</span></summary>

- 现象：`Selector.select()` 持续返回 0 导致 100% CPU 占用（JDK Bug）。
- 方案：自动重建 Selector 并迁移 Channel（Netty 提供 `selectorAutoRebuildThreshold`）；优先使用原生 `epoll/kqueue` 传输以规避。

</details>

### 79.Java 中 HashMap 的扩容机制是怎样的？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--secondary">Java 集合</span> <span class="badge badge--secondary">Java</span></summary>

- 触发：`size > threshold = capacity * loadFactor` 时容量翻倍。
- 再分布：节点按 `hash & oldCap` 决定留在 `oldIndex` 还是移动到 `oldIndex + oldCap`，无需重算完整哈希。
- 树化：单桶元素≥8 且容量≥64 时链表转红黑树；缩容或元素减少可能退化。

</details>

### 80.为什么 Redis 设计为单线程？6.0 版本为何引入多线程？
<details>
<summary>展开 <span class="badge badge--info">中等</span> <span class="badge badge--primary">VIP</span> <span class="badge badge--secondary">后端</span> <span class="badge badge--secondary">Redis</span></summary>

- 单线程原因：简化并发与锁、提升可预测性；主要瓶颈在网络与系统调用而非 CPU。
- 6.0 多线程：引入 I/O 多线程处理读写与协议解析，命令执行仍在单线程，提升吞吐同时保持语义简单。

</details>