"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6356],{28453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>i});var a=t(96540);const s={},l=a.createContext(s);function o(n){const e=a.useContext(l);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),a.createElement(l.Provider,{value:e},n.children)}},28666:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>r,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>u});const a=JSON.parse('{"id":"basicKnowledge/programmingLanguage/Java/\u76f8\u5173\u7684\u95ee\u9898/ConcurrentHashmap\u7684key\u4e3a\u4ec0\u4e48\u4e0d\u80fd\u4e3anull","title":"ConcurrentHashmap\u7684key\u4e3a\u4ec0\u4e48\u4e0d\u80fd\u4e3anull","description":"\u521d\u6b65\u731c\u60f3","source":"@site/docs/basicKnowledge/programmingLanguage/Java/\u76f8\u5173\u7684\u95ee\u9898/ConcurrentHashmap\u7684key\u4e3a\u4ec0\u4e48\u4e0d\u80fd\u4e3anull.md","sourceDirName":"basicKnowledge/programmingLanguage/Java/\u76f8\u5173\u7684\u95ee\u9898","slug":"/basicKnowledge/programmingLanguage/Java/\u76f8\u5173\u7684\u95ee\u9898/ConcurrentHashmap\u7684key\u4e3a\u4ec0\u4e48\u4e0d\u80fd\u4e3anull","permalink":"/kibou/docs/basicKnowledge/programmingLanguage/Java/\u76f8\u5173\u7684\u95ee\u9898/ConcurrentHashmap\u7684key\u4e3a\u4ec0\u4e48\u4e0d\u80fd\u4e3anull","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"programmingLanguage","previous":{"title":"\u679a\u4e3e","permalink":"/kibou/docs/basicKnowledge/programmingLanguage/Java/\u57fa\u7840/\u679a\u4e3e"},"next":{"title":"\u679a\u4e3e\u7684\u7ec4\u5408\u548c\u63a5\u53e3\u5b9e\u73b0","permalink":"/kibou/docs/basicKnowledge/programmingLanguage/Java/\u76f8\u5173\u7684\u95ee\u9898/\u679a\u4e3e\u7684\u7ec4\u5408\u548c\u63a5\u53e3\u5b9e\u73b0"}}');var s=t(74848),l=t(28453);const o={},i=void 0,r={},u=[{value:"\u521d\u6b65\u731c\u60f3",id:"\u521d\u6b65\u731c\u60f3",level:2},{value:"\u7ee7\u7eed\u67e5\u627e\u8d44\u6599",id:"\u7ee7\u7eed\u67e5\u627e\u8d44\u6599",level:2},{value:"\u4f5c\u8005 Doug Lea \u5927\u4f6c\u5165\u573a",id:"\u4f5c\u8005-doug-lea-\u5927\u4f6c\u5165\u573a",level:3},{value:"Joshua Bloch",id:"joshua-bloch",level:3},{value:"\u603b\u7ed3\u4e0b\u6765",id:"\u603b\u7ed3\u4e0b\u6765",level:2}];function c(n){const e={a:"a",blockquote:"blockquote",br:"br",code:"code",details:"details",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",summary:"summary",ul:"ul",...(0,l.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h2,{id:"\u521d\u6b65\u731c\u60f3",children:"\u521d\u6b65\u731c\u60f3"}),"\n",(0,s.jsxs)(e.p,{children:["\u9996\u5148\u662f\u4e0d\u80fd\u4e3anull\uff0c\u6e90\u7801\u5c31\u662f\u8fd9\u4e48\u5199\u7684\uff0c\u800c\u4e14\u5728\u5b9e\u8df5\u4e2d\u9700\u8981\u6ce8\u610f\uff0c\u628aHashMap\u66ff\u6362\u6210ConcurrentHashMap\u540e\uff0c\u5982\u4f55kv\u5b58\u5728null\uff0c\u5c31\u76f4\u63a5\u629b\u51fa\u5f02\u5e38\u4e86\u3002",(0,s.jsx)(e.br,{}),"\n\u81f3\u4e8e\u4e3a\u4ec0\u4e48\u4e0d\u80fd\uff0c\u6211\u7684\u731c\u60f3\u662f\u4f5c\u8005\u53ef\u80fd\u628anull\u5f53\u6210\u7279\u6b8a\u503c\u505a\u4e86\u4e00\u4e9b\u5224\u65ad\uff0c\u4f46\u662f\u76ee\u524d\u6ca1\u627e\u5230\u3002"]}),"\n",(0,s.jsx)(e.h2,{id:"\u7ee7\u7eed\u67e5\u627e\u8d44\u6599",children:"\u7ee7\u7eed\u67e5\u627e\u8d44\u6599"}),"\n",(0,s.jsxs)(e.p,{children:["\u540e\u6765\u5f97\u77e5\u4f5c\u8005Doug Lea\u548cHashMap\u7684\u4f5c\u8005Josh Bloch\u56e0\u4e3a\u8fd9\u4e8b\u8fd8\u4e89\u8bba\u8fc7\uff0c\u4e8e\u662f\u53bb\u627e\u76f8\u5173\u6587\u7ae0\u3002\u539f\u94fe\u63a5\u5df2\u7ecf\u4e0d\u80fd\u8bbf\u95ee\u4e86\uff0c\u8fd9\u8fb9\u627e\u5230\u4e86",(0,s.jsx)(e.a,{href:"https://github.com/kabutz/concurrency-interest-archive/blame/master/archive/2006-05.txt#L2630",children:"\u5b58\u6863"}),"\uff0c\u5185\u5bb9\u5982\u4e0b\uff1a"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"\u8fd9\u4f4d\u8001\u54e5Tutika\u8bb2\u4e86\u4ed6\u4ece HashMap \u66ff\u6362\u4e3a ConcurrentHashMap \u65f6\u5019\u7684\u95ee\u9898\uff0c\u4ed6\u5728HashMap\u5141\u8bb8\u4e86null\u7684\u5b58\u5728\uff0c\n\u4f46\u662fConcurrentHashMap\u4e0d\u5141\u8bb8null\uff0c\u4e8e\u662f\u4ed6\u60f3\u5305\u88c5\u4e00\u5c42ConcurrentHashMap\uff0c\u6765\u8f6c\u5316kv\u7684null\uff0c\u4f46\u662fkeySet()\u3001\nvalues()\u8fd9\u4e9b\u6279\u91cf\u65b9\u6cd5\u5f88\u96be\u64cd\u4f5c\u3002\n__________________________________________________\nHi ,\nI would like to replace some Hashmaps in our\napplication, which are prone to multi threading issues\nwith ConCurrentHashMap.\n\nCurrently we keep null key and values in hashmap\nwithout any issues as HashMap allows them.\n\nBut ConcurrentHashMap does not allow any null key and\nvalues .\n\nI would like to know whether anybody is following any\ngeneral practice to tackle this issue .\n\nIt is very difficult to check for null keys and values\nin my entire application .\n\n\nI thought of writing a wrapper around\nConcurrentHashMap which will mask and unmask key and\nvalues with some other object, when null values are\ngetting inserted .\n\nBut the issue is that in certain bulk operations like\nkeySet() , values() etc, it is very difficult unmask\nthem.\n\nIf anybody has ideas in resolving this kind of issue,\nPlease let me know.\nIt would be helpful to us .\n\nTutika\n"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\u7136\u540e\u4e00\u4f4d\u53ebHolger\u7684\u70ed\u60c5\u7684\u56de\u7b54\u4e86Tutika\uff0c\u5927\u6982\u7684\u610f\u601d\u662f\uff1a\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"\u4f60\u7684\u5e76\u53d1\u95ee\u9898\u4e0d\u5e94\u8be5\u4ec5\u4ec5\u5f15\u5165ConcurrentHashMap\u53bb\u89e3\u51b3\uff08\u6ca1\u61c2\uff09"}),"\n",(0,s.jsx)(e.li,{children:"\u4f60\u5e94\u8be5\u907f\u514dnull\u7684\u60c5\u51b5\uff0c\u5c31\u7b97\u662fHashMap\u4e5f\u4e0d\u5e94\u8be5\u5b58\u653enull"}),"\n",(0,s.jsx)(e.li,{children:"\u53ef\u4ee5\u7528\u5207\u9762\u53bb\u6355\u83b7null\uff0c\u629b\u51fa\u5f02\u5e38\u6216\u8005\u66ff\u6362\u9ed8\u8ba4\u503c"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.details,{children:["\n",(0,s.jsx)(e.summary,{children:"\u5185\u5bb9\u6709\u70b9\u591a\uff0c\u76f4\u63a5\u590d\u5236\u4e0b\u6765"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mail",children:'\nTutika Chakravarthy wrote:\n> I would like to replace some Hashmaps in our\n> application, which are prone to multi threading issues\n> with ConCurrentHashMap.\n\nYou must understand upfront that this may or may not give you the desired\nresults, though it will \'likely\' \'work\' in your case. The\nConcurrentModificationExceptions that you probably see are just a symptom\nof a deeper root cause; it is a good idea to fix that instead of taping up\nthe symptom, simply because it is very likely that you will simply see\nother concurrency bugs after this visible problem has been \'fixed\'.\n\nThe problem with concurrency is not the bugs that you see (like CME); be\nthankful for those.\n\n> Currently we keep null key and values in hashmap\n> without any issues as HashMap allows them.\n\nYes, this is a terrible error in the Java Map classes.\n\n> But ConcurrentHashMap does not allow any null key and\n> values .\n> I would like to know whether anybody is following any\n> general practice to tackle this issue .\n\nMake it caller\'s policy to check for both key and value to be not null.\nInclude tests for this policy in your unit tests (if you have any).\n\n> It is very difficult to check for null keys and values\n> in my entire application .\n\nThis is just the price to pay for using the broken HashMap behaviour in\nthe first place. The "standard" Java libraries are full of these hidden\nlong-term cost factors. :-(\n\n> I thought of writing a wrapper around\n> ConcurrentHashMap which will mask and unmask key and\n> values with some other object, when null values are\n> getting inserted .\n> \n> But the issue is that in certain bulk operations like\n> keySet() , values() etc, it is very difficult unmask\n> them.\n\nRight. Even then you\'d still have the problem that you need to find all\ncallers of the existing Map constructors and fix them up; this may or may\nnot be possible, e.g. if you get the Map from somewhere else.\n\n> If anybody has ideas in resolving this kind of issue,\n> Please let me know.\n\nYou have several options.\n\n1) accept that you have a concurrency problem and fix the root cause, not\njust the symptoms by trying to "fix" the Map behaviour; it is just an\nindicator that something else is wrong. This may mean a full, partial or\nsubsystem-limited concurrency analysis of either the whole application or\nthe affected subsystem (if there are any). This also means that you have\nto come up with a stringent definition of what it means for your\napplication (or the relevant part) to be concurrent. This will expose the\ncritical sections that you can then address, _for example_ by simply using\na Collections.synchronizedMap() around the original, or by using a\nConcurrentHashMap.\n\n1) invert the above approach and \'invade\' all offending code parts with\nAOP; this would enable you to fix existing JARs as well. I have attached a\nsimple AspectJ MapCheck aspect with example that you can weave into your\napplication. Currently this will throw IllegalArgumentExceptions, but of\ncourse you could modify this by skipping the put operation or using\ndefault values. Please think VERY hard whether this works for your case,\nbecause you may end up replacing values with the default key because a\ncaller erroneously passed a null key, or vice versa. The existing aspect\nwas meant to expose the null key/value problems as early as possible.\nSkipping the operation may or may not be a viable option in your case.\n\nThere is no easy solution/quick fix to your problem.\n\nHolger\n-------------- next part --------------\n\npackage mapcheck;\n\nimport java.util.Map;\n\npublic aspect MapNullCheck\n{\n\n\tpointcut methodsToCheck(Object key, Object value):\n\t    call(public Object Map.put(Object, Object))\n\t    && args(key, value)\n\t    && within(MapAccess);\n\n\tObject around(Object key, Object value): methodsToCheck(key, value)\n\t{\n\t\tif (key != null)\n\t\t{\n\t\t\tif (value != null)\n\t\t\t{\n\t\t\t\treturn proceed(key, value);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException("no null values!");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new IllegalArgumentException("no null keys!");\n\t\t}\n\t}\n\n}\n-------------- next part --------------\n\npackage mapcheck;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.log4j.Logger;\n\npublic class MapAccess\n{\n    private static Logger log = Logger.getLogger(MapAccess.class);\n\n    public static void main(String[] args)\n    {\n        Map<String, String> m = new HashMap<String, String>();\n        m.put("foo", "bar");\n        m.put("keyForNullValue", null);\n        m.put(null, "valueForNullKey");\n        log.info("map with nulls: " + m);\n    }\n\n}\n\n'})}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"\u4f5c\u8005-doug-lea-\u5927\u4f6c\u5165\u573a",children:"\u4f5c\u8005 Doug Lea \u5927\u4f6c\u5165\u573a"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["Doug Lea \u5f3a\u8c03\u4e86",(0,s.jsx)(e.code,{children:"map.get(key)"}),"\u8fd4\u56de\u7684null\uff0c\u6ca1\u6cd5\u5224\u65ad\u8fd9\u4e2anull\u662f\u660e\u786e\u7684\u503c\u8fd8\u662f\u8fd9\u4e2akey\u6ca1\u6709\u88ab\u6620\u5c04\uff0c\u8fd9\u4e2a\u95ee\u9898\u5728HashMap\u4e2d\uff0c\u53ef\u4ee5\u901a\u8fc7",(0,s.jsx)(e.code,{children:"contains(key)"}),"\u6765\u68c0\u67e5\uff0c\u4f46\u662f\u5728\u5e76\u53d1\u73af\u5883\u4e2d\uff0c",(0,s.jsx)(e.code,{children:"contains(key)"}),"\u662f\u7ebf\u7a0b\u4e0d\u5b89\u5168\u7684\uff0c\u8fd4\u56de\u503c\u4e0d\u786e\u5b9a\u3002\nDoug Lea \u8bb2\u4e86\u4e2a\u9898\u5916\u8bdd\uff1a\u4ed6\u8ba4\u4e3a\u5728map\u91cc\u5f15\u5165null\u5bb9\u6613\u4ea7\u751f\u9519\u8bef\u3002\u5728\u975e\u7ebf\u7a0b\u5b89\u5168\u7684map\u6216\u8005set\u4e2d\u662f\u5426\u5141\u8bb8null\u4e5f\u662f\u4ed6\u548cJosh Bloch\u957f\u671f\u5b58\u5728\u5206\u6b67\u7684\u95ee\u9898\u3002\nDoug Lea\u7ed9\u51fa\u4e86\u5efa\u8bae\uff1astatic final Object NULL = new Object()\u3002\u7528\u7279\u6b8a\u503c\u53d6\u4ee3null\u3002"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Tutika Chakravarthy wrote:\n> Hi ,\n> I would like to replace some Hashmaps in our\n> application, which are prone to multi threading issues\n> with ConCurrentHashMap.\n> \n> Currently we keep null key and values in hashmap\n> without any issues as HashMap allows them.\n> \n> But ConcurrentHashMap does not allow any null key and\n> values .\n> \n\nTry to take Holger's advice. As mostly an aside though...\n\nThe main reason that nulls aren't allowed in ConcurrentMaps\n(ConcurrentHashMaps, ConcurrentSkipListMaps) is that\nambiguities that may be just barely tolerable in non-concurrent\nmaps can't be accommodated. The main one is that if\nmap.get(key) returns null, you can't detect whether the\nkey explicitly maps to null vs the key isn't mapped.\nIn a non-concurrent map, you can check this via map.contains(key),\nbut in a concurrent one, the map might have changed between calls.\n\nFurther digressing: I personally think that allowing\nnulls in Maps (also Sets) is an open invitation for programs\nto contain errors that remain undetected until\nthey break at just the wrong time. (Whether to allow nulls even\nin non-concurrent Maps/Sets is one of the few design issues surrounding\nCollections that Josh Bloch and I have long disagreed about.)\n\n> \n> It is very difficult to check for null keys and values\n> in my entire application .\n> \n\nWould it be easier to declare somewhere\n   static final Object NULL = new Object();\nand replace all use of nulls in uses of maps with NULL?\n\n-Doug\n"})}),"\n",(0,s.jsx)(e.h3,{id:"joshua-bloch",children:"Joshua Bloch"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"Joshua Bloch\u968f\u540e\u4e5f\u8fdb\u884c\u4e86\u56de\u590d\uff0c\u4ed6\u4e5f\u8ba4\u4e3anull\u53ef\u80fd\u4f1a\u5e26\u6765\u9ebb\u70e6\u3002\u663e\u7136Doug\u6bd4\u4ed6\u66f4\u8ba8\u538cnull\u3002"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"\nDoug,\n\nOn 5/12/06, Doug Lea <dl@cs.oswego.edu> wrote:\n\n> Further digressing: I personally think that allowing\n> nulls in Maps (also Sets) is an open invitation for programs\n> to contain errors that remain undetected until\n> they break at just the wrong time. (Whether to allow nulls even\n> in non-concurrent Maps/Sets is one of the few design issues surrounding\n> Collections that Josh Bloch and I have long disagreed about.)\n\nI have moved towards your position over the years.  It was probably a\nmistake to allow null keys in Maps and null elements in Sets.  I'm\nstill not sure about Map values and List elements.\n\nIn other words, Doug hates null more than I do, but over the years\nI've come to see it as quite troublesome.\n\n       Josh\n"})}),"\n",(0,s.jsx)(e.h2,{id:"\u603b\u7ed3\u4e0b\u6765",children:"\u603b\u7ed3\u4e0b\u6765"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["value\u4e0d\u80fd\u662fnull\u662f\u53ef\u4ee5\u7406\u89e3\u7684\uff0c\u4e3b\u8981\u662f",(0,s.jsx)(e.code,{children:"contains(key)"}),"\u7684\u4e0d\u786e\u5b9a\u6027\u3002\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"contains(key) \u8fd9\u4e2a\u5730\u65b9\u6211\u5148\u662f\u770b\u4e86ConcurrentHashMap\u7684\u6e90\u7801\uff0c\u6709\u70b9\u61f5\uff0c\u8fd9\u4e0d\u53c8\u7ed5\u56deget(key) \u4e86\uff0c\u7136\u540e\u770b\u4e86\u4e0bHashMap\uff0c\u4eba\u5bb6\u662fgetNode\uff0c\u6240\u4ee5\u786e\u5b9e\u80fd\u5224\u65ad\u7684\u51fa\u662f\u4e0d\u662f\u771f\u7684\u5b58\u5728key\u3002"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"// ConcurrentHashMap\npublic boolean containsKey(Object key) {\n\t\treturn get(key) != null;\n\t}\n// HashMap\n public boolean containsKey(Object key) {\n    return getNode(hash(key), key) != null;\n}\n"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"\u5982\u679c\u662f\u771f\u60f3\u5b9e\u73b0\u5224\u65ad\u51fa\u5373\u5b58\u5728key\uff0c\u5e76\u4e14value\u662f\u67d0\u4e2a\u503c\uff0c\u9700\u8981\u5b9e\u73b0getNode\u548cgetVal\u4e4b\u95f4\u7684\u539f\u5b50\u6027\uff0c\u76ee\u524d\u6ca1\u5728ConcurrentHashMap\u627e\u5230\u65b9\u6cd5"}),"\n",(0,s.jsx)(e.li,{children:"\u8fd8\u6709\u4e00\u4e2a\u6709\u6b67\u4e49\u7684\u5730\u65b9\uff0cmerge\uff0ccompute\u8fd9\u4e9b\u65b9\u6cd5\uff0cremappingFunction\u7684\u8c03\u7528\u90fd\u4f1a\u4f20\u5165null\u6216\u8005\u771f\u5b9e\u7684val\uff0c\u800cnull\u8fd9\u65f6\u5019\u660e\u786e\u8868\u793a\u7684\u662fkey\u4e0d\u5b58\u5728\u3002"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"public V compute(K key,\n                 BiFunction<? super K, ? super V, ? extends V> remappingFunction) {\n//.........\n\t            else if ((f = tabAt(tab, i = (n - 1) & h)) == null) {\n            Node<K,V> r = new ReservationNode<K,V>();\n            synchronized (r) {\n                if (casTabAt(tab, i, null, r)) {\n                    binCount = 1;\n                    Node<K,V> node = null;\n                    try {\n                        if ((val = remappingFunction.apply(key, null)) != null) {\n                            delta = 1;\n                            node = new Node<K,V>(h, key, val, null);\n                        }\n                    } finally {\n                        setTabAt(tab, i, node);\n                    }\n                }\n            }\n            if (binCount != 0)\n                break;\n        }\t\t\t\t\n\t\t\t\t }\n"})}),"\n"]}),"\n",(0,s.jsx)(e.li,{children:"\u81f3\u4e8ekey\u4e3a\u4ec0\u4e48\u4e0d\u80fd\u662fnull\u6682\u65f6\u4e0d\u660e\u767d\uff0c\u5927\u6982\u662f\u4f5c\u8005\u4e0d\u559c\u6b22\u5427"}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}}}]);