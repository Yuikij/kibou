"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[3088],{28453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>s});var t=i(96540);const f={},r=t.createContext(f);function o(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(f):n.components||f:o(n.components),t.createElement(r.Provider,{value:e},n.children)}},59419:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"basicSoftware/Linux/Linux\u7684IO\u6a21\u578b","title":"Linux\u7684IO\u6a21\u578b","description":"\u963b\u585eI/O\uff08Blocking I/O\uff09","source":"@site/docs/basicSoftware/Linux/Linux\u7684IO\u6a21\u578b.md","sourceDirName":"basicSoftware/Linux","slug":"/basicSoftware/Linux/Linux\u7684IO\u6a21\u578b","permalink":"/kibou/docs/basicSoftware/Linux/Linux\u7684IO\u6a21\u578b","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"linux","previous":{"title":"\u78c1\u76d8\u64cd\u4f5c","permalink":"/kibou/docs/basicSoftware/Linux/\u5e38\u7528\u547d\u4ee4/\u78c1\u76d8\u64cd\u4f5c"}}');var f=i(74848),r=i(28453);const o={},s=void 0,l={},a=[{value:"\u963b\u585eI/O\uff08Blocking I/O\uff09",id:"\u963b\u585eioblocking-io",level:2},{value:"\u975e\u963b\u585eI/O\uff08Non-blocking I/O\uff09",id:"\u975e\u963b\u585eionon-blocking-io",level:2},{value:"I/O\u591a\u8def\u590d\u7528\uff08I/O Multiplexing\uff09",id:"io\u591a\u8def\u590d\u7528io-multiplexing",level:2},{value:"\u5e38\u7528\u51fd\u6570",id:"\u5e38\u7528\u51fd\u6570",level:3},{value:"\u4fe1\u53f7\u9a71\u52a8I/O\uff08Signal-driven I/O\uff09",id:"\u4fe1\u53f7\u9a71\u52a8iosignal-driven-io",level:2},{value:"\u5f02\u6b65I/O\uff08Asynchronous I/O\uff09",id:"\u5f02\u6b65ioasynchronous-io",level:2}];function d(n){const e={br:"br",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...n.components};return(0,f.jsxs)(f.Fragment,{children:[(0,f.jsx)(e.h2,{id:"\u963b\u585eioblocking-io",children:"\u963b\u585eI/O\uff08Blocking I/O\uff09"}),"\n",(0,f.jsx)(e.p,{children:"\u5f53\u5e94\u7528\u7a0b\u5e8f\u53d1\u8d77\u4e00\u4e2aI/O\u8bf7\u6c42\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u8fdb\u5165\u5185\u6838\u7b49\u5f85\u6570\u636e\u51c6\u5907\u597d\uff0c\u6570\u636e\u8bfb\u53d6\u5b8c\u6210\u540e\u518d\u8fd4\u56de\u5230\u7528\u6237\u6001\u3002\u6b64\u65f6\u8fdb\u7a0b\u4f1a\u56e0\u4e3a\u7b49\u5f85I/O\u64cd\u4f5c\u800c\u957f\u65f6\u95f4\u963b\u585e\u3002"}),"\n",(0,f.jsx)(e.pre,{children:(0,f.jsx)(e.code,{className:"language-cpp",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <string.h>\n#include <sys/time.h>\n#include <errno.h>\n\nvoid print_timestamp(const char* prefix) {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    char timestamp[64];\n    strftime(timestamp, sizeof(timestamp), "%H:%M:%S", localtime(&tv.tv_sec));\n    printf("%s: %s.%06ld\\n", prefix, timestamp, tv.tv_usec);\n}\n\nint main() {\n    const char* fifo_path = "test_fifo";\n    \n    // \u521b\u5efaFIFO\uff08\u547d\u540d\u7ba1\u9053\uff09\n    unlink(fifo_path); // \u5982\u679c\u5df2\u5b58\u5728\u5219\u5220\u9664\n    if (mkfifo(fifo_path, 0666) == -1) {\n        perror("mkfifo failed");\n        return 1;\n    }\n    \n    printf("FIFO created. Waiting for data...\\n");\n    printf("To write to the FIFO, use: echo \\"your message\\" > test_fifo\\n\\n");\n    \n    // \u4ee5\u963b\u585e\u6a21\u5f0f\u6253\u5f00FIFO\n    int fd = open(fifo_path, O_RDONLY);\n    if (fd == -1) {\n        perror("open failed");\n        unlink(fifo_path);\n        return 1;\n    }\n    \n    char buffer[1024];\n    int read_count = 0;\n    \n    while (read_count < 5) { // \u8bfb\u53d65\u6b21\u540e\u9000\u51fa\n        print_timestamp("Waiting for data");\n        printf("Attempting read #%d... (blocked until data arrives)\\n", read_count + 1);\n        \n        // \u963b\u585e\u8bfb\u53d6\n        ssize_t bytes = read(fd, buffer, sizeof(buffer) - 1);\n        // \u4e0d\u80fd\u7acb\u9a6c\u6267\u884c\u6253\u5370\uff0c\u53ea\u6709\u5f53\u8bfb\u53d6\u5230\u6570\u636e\u4e4b\u540e\u518d\u56de\u7ee7\u7eed\n        print_timestamp("Read completed");\n        \n        if (bytes > 0) {\n            buffer[bytes] = \'\\0\';\n            printf("Read %zd bytes: %s\\n", bytes, buffer);\n        } else if (bytes == 0) {\n            printf("Writer closed the FIFO\\n");\n            break;\n        } else {\n            perror("read failed");\n            break;\n        }\n        \n        read_count++;\n        printf("\\nWaiting for next input...\\n\\n");\n    }\n    \n    close(fd);\n    unlink(fifo_path);\n    return 0;\n}\n'})}),"\n",(0,f.jsx)(e.h2,{id:"\u975e\u963b\u585eionon-blocking-io",children:"\u975e\u963b\u585eI/O\uff08Non-blocking I/O\uff09"}),"\n",(0,f.jsx)(e.p,{children:"\u975e\u963b\u585eI/O\u6a21\u578b\u4f7f\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5728I/O\u672a\u5c31\u7eea\u65f6\u7acb\u5373\u8fd4\u56de\uff0c\u800c\u4e0d\u662f\u88ab\u963b\u585e\u3002\u5e94\u7528\u7a0b\u5e8f\u5728\u975e\u963b\u585e\u6a21\u5f0f\u4e0b\uff0c\u4f1a\u4e0d\u65ad\u8f6e\u8be2\uff08polling\uff09\u5185\u6838\u68c0\u67e5I/O\u72b6\u6001\uff0c\u76f4\u5230\u6570\u636e\u51c6\u5907\u597d\u3002\u8fd9\u79cd\u65b9\u5f0f\u907f\u514d\u4e86\u8fdb\u7a0b\u963b\u585e\uff0c\u4f46\u8f6e\u8be2\u6d88\u8017CPU\u8d44\u6e90\uff0c\u4f7f\u5176\u9002\u5408\u5bf9\u5b9e\u65f6\u54cd\u5e94\u6027\u8981\u6c42\u9ad8\u7684\u573a\u666f\uff0c\u4f46\u5728\u5927\u91cfI/O\u60c5\u51b5\u4e0b\u6548\u7387\u4e0d\u4f73\u3002\u800c\u4e14\u5e94\u7528\u7a0b\u5e8f\u65e0\u6cd5\u5f97\u77e5\u6570\u636e\u4ec0\u4e48\u65f6\u5019\u5c31\u7eea\uff0c\u53ea\u80fd\u505a\u5230\u63d2\u5165\u4e00\u6bb5\u903b\u8f91\u4e4b\u540e\u7ee7\u7eed\u8f6e\u8be2\u3002"}),"\n",(0,f.jsx)(e.pre,{children:(0,f.jsx)(e.code,{className:"language-cpp",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <string.h>\n#include <sys/time.h>\n#include <errno.h>\n\nvoid print_timestamp(const char* prefix) {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    char timestamp[64];\n    strftime(timestamp, sizeof(timestamp), "%H:%M:%S", localtime(&tv.tv_sec));\n    printf("%s: %s.%06ld\\n", prefix, timestamp, tv.tv_usec);\n}\n\nvoid set_nonblocking(int fd) {\n    int flags = fcntl(fd, F_GETFL, 0);\n    if (flags == -1) {\n        perror("fcntl F_GETFL failed");\n        exit(1);\n    }\n    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {\n        perror("fcntl F_SETFL failed");\n        exit(1);\n    }\n}\n\nint main() {\n    const char* fifo_path = "test_fifo";\n    \n    // \u521b\u5efaFIFO\n    unlink(fifo_path);\n    if (mkfifo(fifo_path, 0666) == -1) {\n        perror("mkfifo failed");\n        return 1;\n    }\n    \n    printf("FIFO created. Demo of non-blocking I/O...\\n");\n    printf("To write to the FIFO, use: echo \\"your message\\" > test_fifo\\n\\n");\n    \n    // \u4ee5\u975e\u963b\u585e\u6a21\u5f0f\u6253\u5f00FIFO\n    int fd = open(fifo_path, O_RDONLY | O_NONBLOCK);\n    if (fd == -1) {\n        perror("open failed");\n        unlink(fifo_path);\n        return 1;\n    }\n    \n    char buffer[1024];\n    int read_count = 0;\n    \n    // \u6301\u7eed\u8fd0\u884c\uff0c\u76f4\u5230\u8bfb\u53d6\u52305\u6b21\u6570\u636e\n    while (read_count < 5) {\n        print_timestamp("Attempting read");\n        printf("Waiting for data... (read count: %d/5)\\n", read_count);\n        \n        // \u975e\u963b\u585e\u8bfb\u53d6\n        ssize_t bytes = read(fd, buffer, sizeof(buffer) - 1);\n        \n        if (bytes > 0) {\n            // \u6210\u529f\u8bfb\u53d6\u6570\u636e\n            buffer[bytes] = \'\\0\';\n            print_timestamp("Data received");\n            printf("Read %zd bytes: %s\\n", bytes, buffer);\n            read_count++;\n            printf("\\nWaiting for next input...\\n\\n");\n        } else if (bytes == 0) {\n            // \u5199\u5165\u7aef\u5173\u95ed\n            read_count++;\n            printf("Writer closed the FIFO\\n");\n        } else if (errno == EAGAIN || errno == EWOULDBLOCK) {\n            // \u6ca1\u6709\u6570\u636e\u53ef\u8bfb\n            printf("No data available right now\\n");\n            printf("Process can do other things here instead of blocking...\\n");\n        } else {\n            // \u5176\u4ed6\u9519\u8bef\n            perror("read failed");\n            break;\n        }\n        \n        printf("-----------------------------------\\n");\n        sleep(2);  // \u7b49\u5f852\u79d2\u518d\u6b21\u5c1d\u8bd5\n    }\n    \n    printf("Successfully read 5 messages. Exiting...\\n");\n    close(fd);\n    unlink(fifo_path);\n    return 0;\n}\n'})}),"\n",(0,f.jsx)(e.h2,{id:"io\u591a\u8def\u590d\u7528io-multiplexing",children:"I/O\u591a\u8def\u590d\u7528\uff08I/O Multiplexing\uff09"}),"\n",(0,f.jsxs)(e.p,{children:["I/O\u591a\u8def\u590d\u7528\u4f7f\u7528select\u3001poll\u6216epoll\u7b49\u7cfb\u7edf\u8c03\u7528\u6765\u76d1\u63a7\u591a\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u4e00\u65e6\u67d0\u4e2a\u63cf\u8ff0\u7b26\u7684\u72b6\u6001\u53d1\u751f\u53d8\u5316\uff0c\u5c31\u901a\u77e5\u5e94\u7528\u7a0b\u5e8f\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5\u5728\u5355\u4e2a\u7ebf\u7a0b\u6216\u8fdb\u7a0b\u4e2d\u7ba1\u7406\u591a\u4e2aI/O\u64cd\u4f5c\uff0c\u5e38\u7528\u4e8e\u9ad8\u5e76\u53d1\u573a\u666f\u3002I/O\u591a\u8def\u590d\u7528\u907f\u514d\u4e86\u8f6e\u8be2\u6d88\u8017\u7684CPU\u8d44\u6e90\uff0c\u662fWeb\u670d\u52a1\u5668\u7b49\u9ad8\u5e76\u53d1\u5e94\u7528\u7684\u5e38\u7528\u6a21\u578b\u3002",(0,f.jsx)(e.br,{}),"\n\u8be5\u6a21\u578b\u4ecd\u7136\u4f1a\u963b\u585e\u7ebf\u7a0b\u6765\u7b49\u5f85\u7ed3\u679c\uff0c\u4efb\u610f\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u5c31\u7eea\u90fd\u4f1a\u89e3\u9664\u963b\u585e\u3002"]}),"\n",(0,f.jsx)(e.h3,{id:"\u5e38\u7528\u51fd\u6570",children:"\u5e38\u7528\u51fd\u6570"}),"\n",(0,f.jsx)(e.p,{children:"select\uff1a\u9002\u5408\u5c11\u91cf\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u60c5\u51b5\uff0c\u4f46\u968f\u7740\u6587\u4ef6\u63cf\u8ff0\u7b26\u6570\u91cf\u589e\u52a0\u6027\u80fd\u4f1a\u4e0b\u964d\u3002\npoll\uff1a\u548cselect\u7c7b\u4f3c\uff0c\u4f46\u6ca1\u6709\u6587\u4ef6\u63cf\u8ff0\u7b26\u6570\u91cf\u7684\u9650\u5236\u3002\nepoll\uff1aLinux\u7279\u6709\u7684\u591a\u8def\u590d\u7528\u63a5\u53e3\uff0c\u76f8\u6bd4select\u548cpoll\u66f4\u9ad8\u6548\uff0c\u9002\u5408\u5904\u7406\u5927\u91cf\u8fde\u63a5\u7684\u573a\u666f\uff0c\u5982Nginx\u3001Redis\u7b49\u3002"}),"\n",(0,f.jsx)(e.pre,{children:(0,f.jsx)(e.code,{className:"language-cpp",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/epoll.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <sys/time.h>\n\n#define MAX_EVENTS 10\n#define FIFO_COUNT 2\n#define BUFFER_SIZE 1024\n\n// FIFO\u7ed3\u6784\u4f53\ntypedef struct {\n    char *path;           // FIFO\u8def\u5f84\n    int fd;              // \u6587\u4ef6\u63cf\u8ff0\u7b26\n    int writer_existed;   // \u662f\u5426\u66fe\u7ecf\u6709\u5199\u5165\u7aef\n} FifoInfo;\n\nvoid print_timestamp(const char* prefix) {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    char timestamp[64];\n    strftime(timestamp, sizeof(timestamp), "%H:%M:%S", localtime(&tv.tv_sec));\n    printf("%s: %s.%06ld\\n", prefix, timestamp, tv.tv_usec);\n}\n\n// \u8bbe\u7f6e\u975e\u963b\u585e\u6a21\u5f0f\nvoid set_nonblocking(int fd) {\n    int flags = fcntl(fd, F_GETFL, 0);\n    if (flags == -1) {\n        perror("fcntl F_GETFL failed");\n        exit(EXIT_FAILURE);\n    }\n    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {\n        perror("fcntl F_SETFL failed");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// \u521b\u5efa\u548c\u521d\u59cb\u5316FIFO\nvoid init_fifo(FifoInfo *fifo) {\n    unlink(fifo->path);\n    if (mkfifo(fifo->path, 0666) == -1) {\n        perror("mkfifo failed");\n        exit(EXIT_FAILURE);\n    }\n    \n    // \u4ee5\u975e\u963b\u585e\u6a21\u5f0f\u6253\u5f00FIFO\n    fifo->fd = open(fifo->path, O_RDONLY | O_NONBLOCK);\n    if (fifo->fd == -1) {\n        perror("open fifo failed");\n        unlink(fifo->path);\n        exit(EXIT_FAILURE);\n    }\n    set_nonblocking(fifo->fd);\n    fifo->writer_existed = 0;\n    \n    printf("FIFO created: %s\\n", fifo->path);\n}\n\n// \u5904\u7406FIFO\u7684\u8bfb\u53d6\u4e8b\u4ef6\nvoid handle_fifo_read(FifoInfo *fifo) {\n    char buffer[BUFFER_SIZE];\n    print_timestamp(fifo->path);\n    \n    ssize_t bytes = read(fifo->fd, buffer, sizeof(buffer) - 1);\n    \n    if (bytes > 0) {\n        // \u6210\u529f\u8bfb\u53d6\u6570\u636e\n        buffer[bytes] = \'\\0\';\n        printf("%s: Read %zd bytes: %s\\n", fifo->path, bytes, buffer);\n        fifo->writer_existed = 1;\n    } else if (bytes == 0) {\n        if (fifo->writer_existed) {\n            printf("%s: All writers closed\\n", fifo->path);\n        } else {\n            printf("%s: No writer has opened yet\\n", fifo->path);\n        }\n    } else {\n        if (errno == EAGAIN || errno == EWOULDBLOCK) {\n            printf("%s: No data available\\n", fifo->path);\n        } else {\n            perror("read failed");\n        }\n    }\n    printf("-----------------------------------\\n");\n}\n\nint main() {\n    // \u521d\u59cb\u5316FIFO\u4fe1\u606f\n    FifoInfo fifos[FIFO_COUNT] = {\n        {.path = "fifo1"},\n        {.path = "fifo2"}\n    };\n    \n    // \u521b\u5efaepoll\u5b9e\u4f8b\n    int epfd = epoll_create1(0);\n    if (epfd == -1) {\n        perror("epoll_create1 failed");\n        exit(EXIT_FAILURE);\n    }\n    \n    // \u521d\u59cb\u5316\u6240\u6709FIFO\u5e76\u6dfb\u52a0\u5230epoll\n    struct epoll_event ev;\n    for (int i = 0; i < FIFO_COUNT; i++) {\n        init_fifo(&fifos[i]);\n        \n        ev.events = EPOLLIN | EPOLLET;  // \u8fb9\u7f18\u89e6\u53d1\u6a21\u5f0f\n        ev.data.ptr = &fifos[i];\n        \n        if (epoll_ctl(epfd, EPOLL_CTL_ADD, fifos[i].fd, &ev) == -1) {\n            perror("epoll_ctl failed");\n            exit(EXIT_FAILURE);\n        }\n    }\n    \n    printf("\\nWaiting for data. To write to FIFOs, use:\\n");\n    printf("echo \\"message\\" > fifo1\\n");\n    printf("echo \\"message\\" > fifo2\\n\\n");\n    \n    // \u4e8b\u4ef6\u5faa\u73af\n    struct epoll_event events[MAX_EVENTS];\n    while (1) {\n        // \u4f1a\u963b\u585e\u5f53\u524d\u7ebf\u7a0b\uff0c\u4efb\u610f\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u5c31\u7eea\u90fd\u4f1a\u89e3\u9664\u963b\u585e\uff0c\u8fd9\u65f6\u5019\u5c31\u9700\u8981\u518d\u6b21\u8c03\u7528epoll_wait\n        int nfds = epoll_wait(epfd, events, MAX_EVENTS, 5000);  // 5\u79d2\u8d85\u65f6\n        \n        if (nfds == -1) {\n            perror("epoll_wait failed");\n            break;\n        } else if (nfds == 0) {\n            printf("No data received in last 5 seconds...\\n");\n            continue;\n        }\n        \n        // \u5904\u7406\u6240\u6709\u5c31\u7eea\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\n        for (int n = 0; n < nfds; n++) {\n            FifoInfo *fifo = (FifoInfo *)events[n].data.ptr;\n            \n            if (events[n].events & EPOLLIN) {\n                handle_fifo_read(fifo);\n            }\n            \n            if (events[n].events & (EPOLLHUP | EPOLLERR)) {\n                printf("EPOLL error or HUP on %s\\n", fifo->path);\n            }\n        }\n    }\n    \n    // \u6e05\u7406\u8d44\u6e90\n    for (int i = 0; i < FIFO_COUNT; i++) {\n        close(fifos[i].fd);\n        unlink(fifos[i].path);\n    }\n    close(epfd);\n    \n    return 0;\n}\n'})}),"\n",(0,f.jsx)(e.h2,{id:"\u4fe1\u53f7\u9a71\u52a8iosignal-driven-io",children:"\u4fe1\u53f7\u9a71\u52a8I/O\uff08Signal-driven I/O\uff09"}),"\n",(0,f.jsxs)(e.p,{children:["\u5728\u4fe1\u53f7\u9a71\u52a8I/O\u4e2d\uff0c\u5e94\u7528\u7a0b\u5e8f\u901a\u8fc7\u6ce8\u518c\u4e00\u4e2a\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\u6765\u5904\u7406I/O\u4e8b\u4ef6\u3002I/O\u51c6\u5907\u597d\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u5411\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2a\u4fe1\u53f7\uff0c\u901a\u77e5\u5e94\u7528\u7a0b\u5e8f\u5904\u7406\u8be5I/O\u4e8b\u4ef6\u3002",(0,f.jsx)(e.br,{}),"\n",(0,f.jsx)(e.strong,{children:"\u4fe1\u53f7\u9a71\u52a8I/O\u901a\u77e5\u7684\u662fI/O \u51c6\u5907\u5c31\u7eea\u7684\u65f6\u95f4\u70b9\uff0c\u5e94\u7528\u7a0b\u5e8f\u4e3b\u52a8\u8fdb\u884c\u8bfb\u53d6/\u5199\u5165\u3002"})]}),"\n",(0,f.jsx)(e.pre,{children:(0,f.jsx)(e.code,{className:"language-cpp",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <string.h>\n#include <errno.h>\n\n\n#define FIFO_PATH "signal_fifo"\n#define BUFFER_SIZE 1024\n\n// \u5b9a\u4e49\u6587\u4ef6\u63cf\u8ff0\u7b26\u53d8\u91cf\nint fifo_fd;\n\n// \u4fe1\u53f7\u5904\u7406\u51fd\u6570\nvoid handle_io_signal(int signum) {\n    if (signum == SIGIO) {\n        char buffer[BUFFER_SIZE];\n        ssize_t bytes_read;\n\n        // \u4eceFIFO\u8bfb\u53d6\u6570\u636e\n        while ((bytes_read = read(fifo_fd, buffer, sizeof(buffer) - 1)) > 0) {\n            buffer[bytes_read] = \'\\0\';\n            printf("Received %zd bytes: %s\\n", bytes_read, buffer);\n        }\n\n        // \u68c0\u67e5\u662f\u5426\u6ca1\u6709\u6570\u636e\u53ef\u8bfb\n        if (bytes_read == -1 && errno != EAGAIN) {\n            perror("read failed");\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n\nint main() {\n    // \u521b\u5efaFIFO\n    unlink(FIFO_PATH);\n    if (mkfifo(FIFO_PATH, 0666) == -1) {\n        perror("mkfifo failed");\n        exit(EXIT_FAILURE);\n    }\n\n    // \u6253\u5f00FIFO\u5e76\u8bbe\u7f6e\u975e\u963b\u585e\u6a21\u5f0f\n    fifo_fd = open(FIFO_PATH, O_RDONLY | O_NONBLOCK);\n    if (fifo_fd == -1) {\n        perror("open fifo failed");\n        exit(EXIT_FAILURE);\n    }\n\n    // \u8bbe\u7f6e\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\n    struct sigaction sa;\n    sa.sa_handler = handle_io_signal;\n    sa.sa_flags = 0;\n    sigemptyset(&sa.sa_mask);\n    if (sigaction(SIGIO, &sa, NULL) == -1) {\n        perror("sigaction failed");\n        exit(EXIT_FAILURE);\n    }\n\n    // \u914d\u7f6e\u6587\u4ef6\u63cf\u8ff0\u7b26\u63a5\u6536SIGIO\u4fe1\u53f7\n    if (fcntl(fifo_fd, F_SETOWN, getpid()) == -1) {\n        perror("fcntl F_SETOWN failed");\n        exit(EXIT_FAILURE);\n    }\n\n    // \u8bbe\u7f6e\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u4fe1\u53f7\u9a71\u52a8I/O\u548c\u975e\u963b\u585e\u6807\u5fd7\n    int flags = fcntl(fifo_fd, F_GETFL);\n    if (flags == -1) {\n        perror("fcntl F_GETFL failed");\n        exit(EXIT_FAILURE);\n    }\n    if (fcntl(fifo_fd, F_SETFL, flags | O_ASYNC | O_NONBLOCK) == -1) {\n        perror("fcntl F_SETFL failed");\n        exit(EXIT_FAILURE);\n    }\n\n    printf("Waiting for data. To write to FIFO, use:\\n");\n    printf("echo \\"message\\" > %s\\n\\n", FIFO_PATH);\n\n    // \u4e3b\u4e8b\u4ef6\u5faa\u73af\n    while (1) {\n        printf("Doing other work...\\n");\n        sleep(5);  // \u6a21\u62df\u5176\u5b83\u4efb\u52a1\n    }\n\n    // \u6e05\u7406\u8d44\u6e90\n    close(fifo_fd);\n    unlink(FIFO_PATH);\n    return 0;\n}\n\n'})}),"\n",(0,f.jsx)(e.h2,{id:"\u5f02\u6b65ioasynchronous-io",children:"\u5f02\u6b65I/O\uff08Asynchronous I/O\uff09"}),"\n",(0,f.jsxs)(e.p,{children:["\u5f02\u6b65I/O\u6a21\u578b\u8ba9\u5e94\u7528\u7a0b\u5e8f\u5728\u53d1\u8d77I/O\u8bf7\u6c42\u540e\u53ef\u4ee5\u7ee7\u7eed\u6267\u884c\u5176\u4ed6\u64cd\u4f5c\uff0c\u800c\u4e0d\u9700\u7b49\u5f85I/O\u5b8c\u6210\u3002\u5f53I/O\u5b8c\u6210\u540e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u901a\u77e5\u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u5c06\u6570\u636e\u4f20\u9012\u7ed9\u5b83\u3002Linux\u7684aio\u5e93\u63d0\u4f9b\u4e86\u5bf9\u5f02\u6b65I/O\u7684\u652f\u6301\u3002\u5f02\u6b65I/O\u6548\u7387\u6700\u9ad8\uff0c\u4f46\u7f16\u7a0b\u590d\u6742\u5ea6\u8f83\u9ad8\uff0c\u9002\u5408\u4e8e\u8981\u6c42\u9ad8\u541e\u5410\u91cf\u7684\u7cfb\u7edf\uff0c\u5982\u6570\u636e\u5e93\u670d\u52a1\u5668\u7b49\u3002",(0,f.jsx)(e.br,{}),"\n\uff08\u4e0b\u9762\u7684\u4f8b\u5b50\u53ef\u80fd\u4e0d\u5927\u597d\uff0c\u611f\u89c9\u8fd8\u662f\u901a\u8fc7\u8f6e\u8be2io_getevents\u5b9e\u73b0\u7684\uff09\n",(0,f.jsx)(e.strong,{children:"\u5f02\u6b65I/O\u901a\u77e5\u7684\u662fI/O\u64cd\u4f5c\u4f55\u65f6\u5df2\u7ecf\u5b8c\u6210\u3002"})]}),"\n",(0,f.jsx)(e.pre,{children:(0,f.jsx)(e.code,{className:"language-cpp",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <libaio.h>\n#include <sys/stat.h>\n\n#define FIFO_PATH "asynchronous_fifo"\n#define BUFFER_SIZE 1024\n\n// \u5f02\u6b65 I/O \u4e0a\u4e0b\u6587\u548c\u7f13\u51b2\u533a\nio_context_t ctx;\nchar buffer[BUFFER_SIZE];\n\n// \u5f02\u6b65 I/O \u5b8c\u6210\u56de\u8c03\nvoid handle_aio_complete(struct io_event *event) {\n    // \u68c0\u67e5\u8bfb\u53d6\u7ed3\u679c\n    if ((long)event->res > 0) {\n        buffer[event->res] = \'\\0\';\n        printf("Read %ld bytes asynchronously: %s\\n", (long)event->res, buffer);\n    } else {\n        printf("No data read asynchronously or error occurred.\\n");\n    }\n}\n\nint main() {\n    int ret;\n\n    // \u521d\u59cb\u5316\u5f02\u6b65 I/O \u4e0a\u4e0b\u6587\n    memset(&ctx, 0, sizeof(ctx));\n    ret = io_setup(10, &ctx);\n    if (ret < 0) {\n        perror("io_setup failed");\n        exit(EXIT_FAILURE);\n    }\n\n    // \u521b\u5efa FIFO\n    unlink(FIFO_PATH);\n    if (mkfifo(FIFO_PATH, 0666) == -1) {\n        perror("mkfifo failed");\n        exit(EXIT_FAILURE);\n    }\n\n    // \u6253\u5f00 FIFO \u5e76\u8bbe\u7f6e\u4e3a\u975e\u963b\u585e\u6a21\u5f0f\n    int fifo_fd = open(FIFO_PATH, O_RDONLY | O_NONBLOCK);\n    if (fifo_fd == -1) {\n        perror("open FIFO failed");\n        exit(EXIT_FAILURE);\n    }\n\n    printf("Waiting for data. To write to FIFO, use:\\n");\n    printf("echo \\"message\\" > %s\\n\\n", FIFO_PATH);\n\n    while (1) {\n        struct iocb cb;\n        struct iocb *cbs[1] = { &cb };\n        struct io_event events[1];\n\n        // \u51c6\u5907\u5f02\u6b65\u8bfb\u53d6\u64cd\u4f5c\n        io_prep_pread(&cb, fifo_fd, buffer, BUFFER_SIZE - 1, 0);\n\n        // \u63d0\u4ea4\u5f02\u6b65\u8bfb\u53d6\u8bf7\u6c42\n        ret = io_submit(ctx, 1, cbs);\n        if (ret < 0) {\n            perror("io_submit failed");\n            break;\n        }\n\n        // \u7b49\u5f85 I/O \u5b8c\u6210\u4e8b\u4ef6\n        ret = io_getevents(ctx, 1, 1, events, NULL);\n        if (ret < 0) {\n            perror("io_getevents failed");\n            break;\n        }\n\n        // \u8c03\u7528\u56de\u8c03\u5904\u7406\u5b8c\u6210\u4e8b\u4ef6\n        handle_aio_complete(&events[0]);\n\n        // \u6a21\u62df\u5904\u7406\u5176\u4ed6\u4efb\u52a1\n        printf("Doing other work...\\n");\n        sleep(5);\n    }\n\n    // \u5173\u95ed FIFO \u5e76\u6e05\u7406\u5f02\u6b65 I/O \u4e0a\u4e0b\u6587\n    close(fifo_fd);\n    io_destroy(ctx);\n    unlink(FIFO_PATH);\n\n    return 0;\n}\n\n'})})]})}function c(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,f.jsx)(e,{...n,children:(0,f.jsx)(d,{...n})}):d(n)}}}]);